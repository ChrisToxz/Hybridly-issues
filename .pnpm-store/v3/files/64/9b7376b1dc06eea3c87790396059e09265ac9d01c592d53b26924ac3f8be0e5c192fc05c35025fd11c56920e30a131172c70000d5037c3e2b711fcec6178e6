import fs from 'node:fs';
import path from 'node:path';
import colors from 'picocolors';
import { loadEnv } from 'vite';
import 'node:url';
import os from 'node:os';
import makeDebugger from 'debug';
import { isPackageExists, resolveModule, importModule } from 'local-pkg';
import { execSync } from 'node:child_process';
import MagicString from 'magic-string';
import run from 'vite-plugin-run';
import { merge } from '@hybridly/utils';
import autoimport from 'unplugin-auto-import/vite';
import vueComponents from 'unplugin-vue-components/vite';
import { HeadlessUiResolver } from 'unplugin-vue-components/resolvers';
import iconsResolver from 'unplugin-icons/resolver';
import icons from 'unplugin-icons/vite';
import { FileSystemIconLoader } from 'unplugin-icons/loaders';
import vue from '@vitejs/plugin-vue';

function isIpv6(address) {
  return address.family === "IPv6" || address.family === 6;
}

function determineDevelopmentEnvironmentConfigPath() {
  const herdConfigPath = path.resolve(os.homedir(), "Library", "Application Support", "Herd", "config", "valet");
  if (fs.existsSync(herdConfigPath)) {
    return herdConfigPath;
  }
  return path.resolve(os.homedir(), ".config", "valet");
}
function resolveDevelopmentEnvironmentHost(configPath) {
  const configFile = path.resolve(configPath, "config.json");
  if (!fs.existsSync(configFile)) {
    throw new Error(`Unable to find the configuration file [${configFile}]. You will need to manually specify the host in the \`detectTls\` configuration option.`);
  }
  const config = JSON.parse(fs.readFileSync(configFile, "utf-8"));
  return `${path.basename(process.cwd())}.${config.tld}`;
}
function resolveDevelopmentEnvironmentServerConfig() {
  const configPath = determineDevelopmentEnvironmentConfigPath();
  const host = resolveDevelopmentEnvironmentHost(configPath);
  const keyPath = path.resolve(configPath, "Certificates", `${host}.key`);
  const certPath = path.resolve(configPath, "Certificates", `${host}.crt`);
  if (!fs.existsSync(keyPath) || !fs.existsSync(certPath)) {
    return;
  }
  return {
    hmr: { host },
    host,
    https: {
      key: fs.readFileSync(keyPath),
      cert: fs.readFileSync(certPath)
    }
  };
}
function resolveEnvironmentServerConfig(env) {
  if (!env.VITE_DEV_SERVER_KEY && !env.VITE_DEV_SERVER_CERT) {
    return;
  }
  if (!fs.existsSync(env.VITE_DEV_SERVER_KEY) || !fs.existsSync(env.VITE_DEV_SERVER_CERT)) {
    throw new Error(`Unable to find the certificate files specified in your environment. Ensure you have correctly configured VITE_DEV_SERVER_KEY: [${env.VITE_DEV_SERVER_KEY}] and VITE_DEV_SERVER_CERT: [${env.VITE_DEV_SERVER_CERT}].`);
  }
  const host = resolveHostFromEnv(env);
  return {
    hmr: { host },
    host,
    https: {
      key: fs.readFileSync(env.VITE_DEV_SERVER_KEY),
      cert: fs.readFileSync(env.VITE_DEV_SERVER_CERT)
    }
  };
}
function resolveHostFromEnv(env) {
  if (env.VITE_DEV_SERVER_KEY) {
    return env.VITE_DEV_SERVER_KEY;
  }
  try {
    return new URL(env.APP_URL).host;
  } catch {
    throw new Error(`Unable to determine the host from the environment's APP_URL: [${env.APP_URL}].`);
  }
}

let exitHandlersBound = false;
function laravel(options, hybridlyConfig) {
  let viteDevServerUrl;
  let resolvedConfig;
  let userConfig;
  const publicDirectory = "public";
  const buildDirectory = "build";
  const hotFile = path.join(publicDirectory, "hot");
  return {
    name: "hybridly:laravel",
    enforce: "post",
    config: (config, { command, mode }) => {
      userConfig = config;
      const ssr = !!userConfig.build?.ssr;
      const env = loadEnv(mode, userConfig.envDir || process.cwd(), "");
      const assetUrl = env.ASSET_URL ?? "";
      const base = `${assetUrl + (!assetUrl.endsWith("/") ? "/" : "") + buildDirectory}/`;
      const serverConfig = command === "serve" ? resolveEnvironmentServerConfig(env) ?? resolveDevelopmentEnvironmentServerConfig() : void 0;
      ensureCommandShouldRunInEnvironment(command, env);
      return {
        base: userConfig.base ?? (command === "build" ? base : ""),
        publicDir: userConfig.publicDir ?? false,
        build: {
          manifest: ssr === true ? false : userConfig.build?.manifest ?? "manifest.json",
          outDir: userConfig.build?.outDir ?? path.join(publicDirectory, buildDirectory),
          rollupOptions: {
            input: resolveInput(config, hybridlyConfig)
          },
          assetsInlineLimit: userConfig.build?.assetsInlineLimit ?? 0
        },
        server: {
          origin: userConfig.server?.origin ?? "__laravel_vite_placeholder__",
          ...process.env.LARAVEL_SAIL ? {
            host: userConfig.server?.host ?? "0.0.0.0",
            port: userConfig.server?.port ?? (env.VITE_PORT ? parseInt(env.VITE_PORT) : 5173),
            strictPort: userConfig.server?.strictPort ?? true
          } : void 0,
          ...serverConfig ? {
            host: userConfig.server?.host ?? serverConfig.host,
            hmr: userConfig.server?.hmr === false ? false : {
              ...serverConfig.hmr,
              ...userConfig.server?.hmr === true ? {} : userConfig.server?.hmr
            },
            https: userConfig.server?.https ?? serverConfig.https
          } : void 0
        }
      };
    },
    configResolved(config) {
      resolvedConfig = config;
    },
    transform(code) {
      if (resolvedConfig.command === "serve") {
        return code.replace(/__laravel_vite_placeholder__/g, viteDevServerUrl);
      }
    },
    configureServer(server) {
      const envDir = resolvedConfig.envDir || process.cwd();
      const appUrl = loadEnv(resolvedConfig.mode, envDir, "APP_URL").APP_URL ?? "undefined";
      server.httpServer?.once("listening", () => {
        const address = server.httpServer?.address();
        const isAddressInfo = (x) => typeof x === "object";
        if (isAddressInfo(address)) {
          viteDevServerUrl = resolveDevServerUrl(address, server.config, userConfig);
          fs.writeFileSync(hotFile, viteDevServerUrl);
          if (!hybridlyConfig.versions) {
            return;
          }
          let registered = `${colors.bold(hybridlyConfig.components.views.length)} ${colors.dim("views")}, `;
          registered += `${colors.bold(hybridlyConfig.components.components.length)} ${colors.dim("components")}, `;
          registered += `${colors.bold(hybridlyConfig.components.layouts.length)} ${colors.dim("layouts")}, `;
          registered += `${colors.bold(hybridlyConfig.components.directories.length)} ${colors.dim("directories")}`;
          const latest = hybridlyConfig.versions.is_latest ? "" : colors.dim(`(${colors.yellow(`${hybridlyConfig.versions.latest} is available`)})`);
          let version = `${colors.yellow(`v${hybridlyConfig.versions.composer}`)} ${colors.dim("(composer)")}, `;
          version += `${colors.yellow(`v${hybridlyConfig.versions.npm}`)} ${colors.dim("(npm)")}`;
          version += ` \u2014 ${colors.yellow("this may lead to undefined behavior")}`;
          setTimeout(() => {
            server.config.logger.info(`
  ${colors.magenta(`${colors.bold("HYBRIDLY")} v${hybridlyConfig.versions.composer}`)}  ${latest}`);
            server.config.logger.info("");
            server.config.logger.info(`  ${colors.green("\u279C")}  ${colors.bold("URL")}: ${colors.cyan(hybridlyConfig.routing.url)}`);
            server.config.logger.info(`  ${colors.green("\u279C")}  ${colors.bold("Registered")}: ${registered}`);
            if (hybridlyConfig.versions.composer !== hybridlyConfig.versions.npm) {
              server.config.logger.info(`  ${colors.yellow("\u279C")}  ${colors.bold("Version mismatch")}: ${version}`);
            }
          }, 100);
        }
      });
      if (!exitHandlersBound) {
        let clean = function() {
          if (fs.existsSync(hotFile)) {
            fs.rmSync(hotFile);
          }
        };
        process.on("exit", clean);
        process.on("SIGINT", () => process.exit());
        process.on("SIGTERM", () => process.exit());
        process.on("SIGHUP", () => process.exit());
        exitHandlersBound = true;
      }
      return () => server.middlewares.use((req, res, next) => {
        if (req.url === "/index.html") {
          res.writeHead(302, { Location: appUrl });
          res.end();
        }
        next();
      });
    }
  };
}
function ensureCommandShouldRunInEnvironment(command, env) {
  if (command === "build" || env.LARAVEL_BYPASS_ENV_CHECK === "1") {
    return;
  }
  if (typeof env.LARAVEL_VAPOR !== "undefined") {
    throw new TypeError("You should not run the Vite HMR server on Vapor. You should build your assets for production instead. To disable this ENV check you may set LARAVEL_BYPASS_ENV_CHECK=1");
  }
  if (typeof env.LARAVEL_FORGE !== "undefined") {
    throw new TypeError("You should not run the Vite HMR server in your Forge deployment script. You should build your assets for production instead. To disable this ENV check you may set LARAVEL_BYPASS_ENV_CHECK=1");
  }
  if (typeof env.LARAVEL_ENVOYER !== "undefined") {
    throw new TypeError("You should not run the Vite HMR server in your Envoyer hook. You should build your assets for production instead. To disable this ENV check you may set LARAVEL_BYPASS_ENV_CHECK=1");
  }
  if (typeof env.CI !== "undefined") {
    throw new TypeError("You should not run the Vite HMR server in CI environments. You should build your assets for production instead. To disable this ENV check you may set LARAVEL_BYPASS_ENV_CHECK=1");
  }
}
function resolveInput(userConfig, hybridlyConfig, ssr) {
  return userConfig.build?.rollupOptions?.input ?? hybridlyConfig.architecture.application_main_path;
}
function resolveDevServerUrl(address, config, userConfig) {
  const configHmrProtocol = typeof config.server.hmr === "object" ? config.server.hmr.protocol : null;
  const clientProtocol = configHmrProtocol ? configHmrProtocol === "wss" ? "https" : "http" : null;
  const serverProtocol = config.server.https ? "https" : "http";
  const protocol = clientProtocol ?? serverProtocol;
  const configHmrHost = typeof config.server.hmr === "object" ? config.server.hmr.host : null;
  const configHost = typeof config.server.host === "string" ? config.server.host : null;
  const sailHost = process.env.LARAVEL_SAIL && !userConfig.server?.host ? "localhost" : null;
  const serverAddress = isIpv6(address) ? `[${address.address}]` : address.address;
  const host = configHmrHost ?? sailHost ?? configHost ?? serverAddress;
  const configHmrClientPort = typeof config.server.hmr === "object" ? config.server.hmr.clientPort : null;
  const port = configHmrClientPort ?? address.port;
  return `${protocol}://${host}:${port}`;
}

const LAYOUT_PLUGIN_NAME = "vite:hybridly:layout";
const CONFIG_PLUGIN_NAME = "vite:hybridly:config";
const CONFIG_VIRTUAL_MODULE_ID = "virtual:hybridly/config";
const RESOLVED_CONFIG_VIRTUAL_MODULE_ID = `\0${CONFIG_VIRTUAL_MODULE_ID}`;

const debug = {
  config: makeDebugger(CONFIG_PLUGIN_NAME),
  layout: makeDebugger(LAYOUT_PLUGIN_NAME)
};
function isPackageInstalled(name, paths = [process.cwd()]) {
  return isPackageExists(name, { paths });
}
function importPackage(name, paths = [process.cwd()]) {
  const mod = resolveModule(name, { paths });
  if (!mod) {
    console.warn(`Could not resolve package [${name}]`);
    return;
  }
  return importModule(mod);
}
function toKebabCase(key) {
  const result = key.replace(/([A-Z])/g, " $1").trim();
  return result.split(" ").join("-").toLowerCase();
}

function generateTsConfig(options, config) {
  const tsconfig = {
    compilerOptions: {
      target: "esnext",
      module: "esnext",
      moduleResolution: "bundler",
      strict: true,
      jsx: "preserve",
      sourceMap: true,
      resolveJsonModule: true,
      esModuleInterop: true,
      allowSyntheticDefaultImports: true,
      lib: [
        "esnext",
        "dom"
      ],
      types: [
        "vite/client",
        "hybridly/client",
        ...options.icons !== false ? ["unplugin-icons/types/vue"] : [],
        ...options.tsconfig?.types ?? []
      ],
      baseUrl: "..",
      paths: {
        "#/*": [
          ".hybridly/*"
        ],
        "~/*": [
          "./*"
        ],
        "@/*": [
          `./${config.architecture.root_directory}/*`
        ]
      }
    },
    include: [
      ...config.components.views.map(({ path: path2 }) => `../${path2}`),
      ...config.components.layouts.map(({ path: path2 }) => `../${path2}`),
      ...config.components.components.map(({ path: path2 }) => `../${path2}`),
      `../${config.architecture.root_directory}/**/*`,
      "../app/**/*",
      "../src/**/*",
      "./php-types.d.ts",
      "./global-types.d.ts",
      "./routes.d.ts",
      "./components.d.ts",
      "./auto-imports.d.ts",
      ...options.tsconfig?.include ?? []
    ],
    exclude: [
      "../public/**/*",
      ...options.tsconfig?.exclude ?? []
    ]
  };
  write(JSON.stringify(tsconfig, null, 2), "tsconfig.json");
}
function generateLaravelIdeaHelper(config) {
  const ideJson = {
    $schema: "https://laravel-ide.com/schema/laravel-ide-v2.json",
    completions: [
      {
        complete: "staticStrings",
        options: {
          strings: config.components.views.map(({ identifier }) => identifier)
        },
        condition: [
          {
            functionNames: ["hybridly"],
            parameters: [1]
          }
        ]
      }
    ]
  };
  write(JSON.stringify(ideJson, null, 2), "ide.json");
}
async function generateRouteDefinitionFile(options, config) {
  const routing = config?.routing;
  if (!routing) {
    return;
  }
  debug.config("Writing types for routing:", routing);
  const routes = Object.fromEntries(Object.entries(routing.routes).map(([key, route]) => {
    const bindings = route.bindings ? Object.fromEntries(Object.entries(route.bindings).map(([key2]) => [key2, "__key_placeholder__"])) : void 0;
    return [key, {
      ...route.uri ? { uri: route.uri } : {},
      ...route.domain ? { domain: route.domain } : {},
      ...route.wheres ? { wheres: route.wheres } : {},
      ...route.bindings ? { bindings } : {}
    }];
  }));
  const definitions = `
		/* eslint-disable */
		/* prettier-ignore */
		// This file has been automatically generated by Hybridly
		// Modifications will be discarded
		
		declare module 'hybridly' {
			export interface GlobalRouteCollection {
				url: '__URL__'
				routes: __ROUTES__
			}
		}
		
		export {}
	`.replace("__URL__", routing?.url ?? "").replace("__ROUTES__", JSON.stringify(routes).replaceAll('"__key_placeholder__"', "any"));
  write(definitions, "routes.d.ts");
}
function write(data, filename) {
  const hybridlyPath = path.resolve(process.cwd(), ".hybridly");
  if (!fs.existsSync(hybridlyPath)) {
    fs.mkdirSync(hybridlyPath);
  }
  fs.writeFileSync(path.resolve(hybridlyPath, filename), data, {
    encoding: "utf-8"
  });
}

async function loadConfiguration(options) {
  try {
    const php = options.php ?? process.env.PHP_EXECUTABLE_PATH ?? "php";
    const stdout = execSync(`${php} artisan hybridly:config`);
    return JSON.parse(stdout.toString("utf-8"));
  } catch (e) {
    console.error("Could not load configuration from [php artisan].");
    throw e;
  }
}

function getClientCode$1(config) {
  const paths = config.components.views.map(({ path }) => `"~/${path}"`).join(",");
  return `
		import { initializeHybridly as init } from 'hybridly/vue'

		export function initializeHybridly(config) {
			return init({
				...${JSON.stringify(config)},
				imported: import.meta.glob([${paths}], { eager: ${config.components.eager ?? true} }),
				...config,
			})
		}
 `;
}

const initialize = (options, config) => {
  generateTsConfig(options, config);
  generateLaravelIdeaHelper(config);
  generateRouteDefinitionFile(options, config);
  return {
    name: CONFIG_PLUGIN_NAME,
    enforce: "pre",
    config() {
      return {
        resolve: {
          alias: {
            "@": path.join(process.cwd(), config.architecture.root_directory),
            "#": path.join(process.cwd(), ".hybridly"),
            "~": path.join(process.cwd())
          }
        }
      };
    },
    configureServer(server) {
      let restarting = false;
      async function forceRestart(message) {
        if (restarting) {
          return;
        }
        restarting = true;
        server.config.logger.info(`${message}: forcing a server restart.`, {
          clear: server.config.clearScreen,
          timestamp: true
        });
        return await server?.restart();
      }
      async function handleFileChange(file) {
        if (file.endsWith("config/hybridly.php")) {
          return await forceRestart("Configuration file changed");
        }
        if (/routes\/.*\.php/.test(file) || /routes\.php/.test(file)) {
          return await forceRestart("Routing changed");
        }
        if (/.*\.vue$/.test(file)) {
          const updatedConfig = await loadConfiguration(options);
          const viewsOrLayoutsChanged = didViewsOrLayoutsChange(updatedConfig, config);
          if (viewsOrLayoutsChanged) {
            return await forceRestart("View or layout changed");
          }
        }
      }
      server.watcher.on("add", handleFileChange);
      server.watcher.on("change", handleFileChange);
      server.watcher.on("unlink", handleFileChange);
    },
    resolveId(id) {
      if (id === CONFIG_VIRTUAL_MODULE_ID) {
        return RESOLVED_CONFIG_VIRTUAL_MODULE_ID;
      }
    },
    async load(id) {
      if (id === RESOLVED_CONFIG_VIRTUAL_MODULE_ID) {
        return getClientCode$1(config);
      }
    },
    // Denies HMR for `.hybridly` content, it causes unwanted reloads
    async handleHotUpdate(ctx) {
      if (ctx.file.includes(".hybridly")) {
        return [];
      }
    }
  };
};
function didViewsOrLayoutsChange(updatedConfig, previousConfig) {
  if (!previousConfig) {
    return false;
  }
  return JSON.stringify(updatedConfig.components.views) !== JSON.stringify(previousConfig.components.views) || JSON.stringify(updatedConfig.components.layouts) !== JSON.stringify(previousConfig.components.layouts);
}

const TEMPLATE_LAYOUT_REGEX = /<template +layout(?: *= *['"]((?:[\w\/\-_,:](?:,\ )?)+)['"] *)?>/;
const TYPESCRIPT_REGEX = /lang=['"]ts['"]/;
const layout = (options, config) => {
  const defaultLayoutName = options?.layout?.defaultLayoutName?.replace(".vue", "") ?? "default";
  const templateRegExp = options?.layout?.templateRegExp ?? TEMPLATE_LAYOUT_REGEX;
  debug.layout("Resolved options:", {
    defaultLayoutName
  });
  return {
    name: LAYOUT_PLUGIN_NAME,
    enforce: "pre",
    transform: (code, id) => {
      if (!templateRegExp.test(code)) {
        return;
      }
      const source = new MagicString(code);
      const updatedCode = source.replace(templateRegExp, (_, layoutName) => {
        const isTypeScript = TYPESCRIPT_REGEX.test(code);
        const layouts = layoutName?.toString()?.replaceAll(" ", "").split(",") ?? [defaultLayoutName];
        const importName = (i) => `__hybridly_layout_${i}`;
        const exports = layouts.map((_2, i) => importName(i));
        const imports = layouts.reduce((imports2, layoutName2, i) => `
					${imports2}
					import ${importName(i)} from '${resolveLayoutImportPath(layoutName2, config)}';
				`, "").trim();
        debug.layout(`Resolved layouts "${layouts.join(", ")}":`, {
          sourceFile: id,
          layouts,
          imports
        });
        return `
					<script${isTypeScript ? ' lang="ts"' : ""}>
					${imports}
					export default { layout: [${exports.join(", ")}] }
					<\/script>
					<template>
				`;
      });
      return {
        map: updatedCode.generateMap(),
        code: updatedCode.toString()
      };
    }
  };
};
function resolveLayoutImportPath(name, config) {
  const { path } = config.components.layouts.find((layout) => layout.identifier === name) ?? {};
  if (!path) {
    throw new Error(`Layout [${name}] could not be found.`);
  }
  return `~/${path}`;
}

function getRunOptions(options) {
  if (options.run === false) {
    return [];
  }
  return [
    {
      name: "Generate TypeScript types",
      run: ["php", "artisan", "hybridly:types"],
      pattern: [
        "+(app|src)/**/*Data.php",
        "+(app|src)/**/Enums/*.php",
        "+(app|src)/**/Middleware/HandleHybridRequests.php"
      ]
    },
    {
      name: "Generate i18n",
      run: ["php", "artisan", "hybridly:i18n"],
      pattern: "lang/**/*.php"
    },
    ...options.run ?? []
  ];
}

const HybridlyImports = {
  "hybridly/vue": [
    "useProperty",
    "setProperty",
    "useRefinements",
    "useTable",
    "useBulkSelect",
    "useProperties",
    "useBackForward",
    "useContext",
    "useForm",
    "useDialog",
    "useHistoryState",
    "usePaginator",
    "defineLayout",
    "defineLayoutProperties",
    "registerHook",
    "useRoute",
    "useQueryParameters"
  ],
  "hybridly": [
    "router",
    "route",
    "can"
  ]
};
function getAutoImportsOptions(options, config) {
  if (options.autoImports === false) {
    return;
  }
  const presets = ["@vueuse/core", "vue-i18n"];
  const custom = {
    "@unhead/vue": [
      "useHead",
      "useSeoMeta"
    ],
    "@innocenzi/utils": [
      "match",
      "invoke",
      "batchInvoke",
      "asyncInvoke"
    ]
  };
  return merge(
    {
      vueTemplate: true,
      dts: ".hybridly/auto-imports.d.ts",
      dirs: [
        `${config.architecture.root_directory}/utils`,
        `${config.architecture.root_directory}/composables`,
        ...config.components.directories.map((directory) => `${directory}/**/*.ts`)
      ],
      imports: [
        "vue",
        "vue/macros",
        ...presets.filter((pkg) => isPackageInstalled(pkg)),
        ...Object.entries(custom).filter(([pkg]) => isPackageInstalled(pkg)).map(([pkg, imports]) => ({ [pkg]: imports })),
        HybridlyImports
      ]
    },
    options.autoImports ?? {},
    { overwriteArray: false }
  );
}

async function getVueComponentsOptions(options, config) {
  if (options.vueComponents === false) {
    return {};
  }
  const hasIcons = options?.icons !== false;
  const customCollections = Array.isArray(options.customIcons) ? options.customIcons : options.customIcons?.collections ?? [];
  const overrideResolvers = options.overrideResolvers ? Array.isArray(options.overrideResolvers) ? options.overrideResolvers : [options.overrideResolvers] : false;
  const hasHeadlessUI = isPackageInstalled("@headlessui/vue");
  const hasRadix = isPackageInstalled("radix-vue");
  return merge(
    {
      dirs: [
        `./${config.architecture.root_directory}/${config.architecture.components_directory}`
      ],
      directoryAsNamespace: true,
      dts: ".hybridly/components.d.ts",
      resolvers: overrideResolvers || [
        ...hasIcons ? [iconsResolver({ customCollections })] : [],
        ...hasHeadlessUI ? [HeadlessUiResolver({ prefix: options?.vueComponents?.headlessUiPrefix ?? "Headless" })] : [],
        ...hasRadix ? [await RadixResolver(options?.vueComponents?.radixPrefix)] : [],
        ProvidedComponentListResolver(config),
        HybridlyResolver(options.vueComponents?.linkName)
      ]
    },
    options.vueComponents ?? {},
    { overwriteArray: false }
  );
}
async function RadixResolver(prefix = "Radix") {
  const radix = await importPackage("radix-vue/resolver");
  return radix.default({ prefix });
}
function HybridlyResolver(linkName = "RouterLink") {
  return {
    type: "component",
    resolve: (name) => {
      if (name === linkName) {
        return {
          from: "hybridly/vue",
          name: "RouterLink",
          as: linkName
        };
      }
    }
  };
}
function ProvidedComponentListResolver(config) {
  function resolveComponentPath(name) {
    const kebabName = toKebabCase(name);
    const path = config.components.components.find((view) => {
      const identifierAsComponentName = view.identifier.replace("::", "-").replace(".", "-");
      return identifierAsComponentName === kebabName;
    })?.path;
    if (!path) {
      return;
    }
    return `~/${path}`;
  }
  return {
    type: "component",
    resolve: (name) => resolveComponentPath(name)
  };
}

function getIconsOptions(options, config) {
  if (options.icons === false) {
    return {};
  }
  const resolved = Array.isArray(options.customIcons) ? { icons: void 0, collections: options.customIcons } : options.customIcons;
  const customIconDirectoryName = resolved?.icons ?? "icons";
  const customCollections = Object.fromEntries(resolved?.collections?.map((collection) => [
    collection,
    FileSystemIconLoader(`./${config.architecture.root_directory}/${customIconDirectoryName}/${collection}`)
  ]) ?? []);
  return {
    autoInstall: true,
    customCollections,
    ...options.icons
  };
}

function getVueOptions(options) {
  if (options.vue === false) {
    return;
  }
  return merge(
    {
      template: {
        transformAssetUrls: {
          base: null,
          includeAbsolute: false
        },
        ...options.vue?.template
      },
      script: {
        globalTypeFiles: [
          path.resolve(".hybridly/php-types.d.ts")
        ],
        defineModel: true,
        ...options.vue?.script
      }
    },
    options.vue ?? {},
    { overwriteArray: false }
  );
}

function killSwitch() {
  let _enabled = false;
  return {
    name: "hybridly:build:kill-switch",
    config: ({ mode }) => {
      if (mode === "build") {
        _enabled = true;
      }
    },
    buildEnd: (error) => {
      if (!_enabled) {
        return;
      }
      if (error) {
        console.error("Error when bundling");
        console.error(error);
        process.exit(1);
      }
    },
    closeBundle: () => {
      if (!_enabled) {
        return;
      }
      process.exit(0);
    }
  };
}

function getClientCode() {
  const style = `
		.local-build {
			position: fixed;
			bottom: 1rem;
			left: 1rem;
			z-index: 50;
			display: inline-flex;
			max-width: 26rem;
			align-items: center;
			background-color: rgba(0, 0, 0, 0.9);
			padding: 0.75rem;
			font-size: 0.75rem;
			color: #8C8C8C;
			transition: opacity 0.3s;
		}

		.local-build:hover {
			opacity: 0.1;
		}

		.local-build .icon {
			margin-right: 0.5rem;
			height: 1.25rem;
			width: 1.25rem;
			fill: currentColor;
		}

		.local-build .content {
			display: inline-flex;
			flex-direction: column;
			gap: 0.5rem;
		}

		.local-build .title {
			font-weight: 500;
		}
	`;
  const html = `
		<div class="local-build">
		<svg viewBox="0 0 24 24" width="1.2em" height="1.2em" class="icon"><path fill="currentColor" d="M11 15h2v2h-2zm0-8h2v6h-2zm1-5C6.47 2 2 6.5 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2m0 18a8 8 0 0 1-8-8a8 8 0 0 1 8-8a8 8 0 0 1 8 8a8 8 0 0 1-8 8"></path></svg>
			<span class="content">
					<span class="title">This is a local production build. Changes will not be reflected.</span>
			</span>
		</div>
		`;
  return `
		;(function() {
			const style = document.createElement('style')
			style.innerHTML = \`${style}\`
			document.head.appendChild(style)

			const html = document.createElement('div')
			html.innerHTML = \`${html}\`
			document.body.appendChild(html)
			html.addEventListener('click', () => html.remove())
		})()
	`;
}

const LOCAL_BUILD_VIRTUAL_ID = "virtual:hybridly/local-build";
const RESOLVED_LOCAL_BUILD_VIRTUAL_ID = `\0${LOCAL_BUILD_VIRTUAL_ID}`;
function warnOnLocalBuilds() {
  let shouldDisplayWarning = false;
  return {
    name: "vite:hybridly:local-build",
    enforce: "pre",
    apply: "build",
    config(config, { mode }) {
      const env = loadEnv(mode, config.envDir ?? process.cwd(), "");
      shouldDisplayWarning = env.APP_ENV === "local";
    },
    async resolveId(id) {
      if (!shouldDisplayWarning) {
        return;
      }
      if (id === LOCAL_BUILD_VIRTUAL_ID) {
        return RESOLVED_LOCAL_BUILD_VIRTUAL_ID;
      }
    },
    async load(id) {
      if (!shouldDisplayWarning) {
        return;
      }
      if (id === RESOLVED_LOCAL_BUILD_VIRTUAL_ID) {
        return getClientCode();
      }
    },
    transform(code, id) {
      if (!shouldDisplayWarning) {
        return;
      }
      if (!id.endsWith(CONFIG_VIRTUAL_MODULE_ID)) {
        return;
      }
      code = `${code}
import '${LOCAL_BUILD_VIRTUAL_ID}'`;
      return code;
    }
  };
}

async function plugin(options = {}) {
  const config = await loadConfiguration(options);
  return [
    initialize(options, config),
    layout(options, config),
    options.laravel !== false && laravel(options, config),
    options.run !== false && run(getRunOptions(options)),
    options.vueComponents !== false && vueComponents(await getVueComponentsOptions(options, config)),
    options.autoImports !== false && autoimport(getAutoImportsOptions(options, config)),
    options.icons !== false && icons(getIconsOptions(options, config)),
    options.vue !== false && vue(getVueOptions(options)),
    options.killSwitch !== false && killSwitch(),
    options.warnOnLocalBuilds !== false && warnOnLocalBuilds()
  ];
}

export { HybridlyImports, HybridlyResolver, plugin as default, layout };
