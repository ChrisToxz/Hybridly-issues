import laravel from 'laravel-vite-plugin';
import path from 'node:path';
import fs from 'node:fs';
import makeDebugger from 'debug';
import { isPackageExists, resolveModule, importModule } from 'local-pkg';
import { execSync } from 'node:child_process';
import MagicString from 'magic-string';
import run from 'vite-plugin-run';
import { merge } from '@hybridly/utils';
import autoimport from 'unplugin-auto-import/vite';
import vueComponents from 'unplugin-vue-components/vite';
import { HeadlessUiResolver } from 'unplugin-vue-components/resolvers';
import iconsResolver from 'unplugin-icons/resolver';
import icons from 'unplugin-icons/vite';
import { FileSystemIconLoader } from 'unplugin-icons/loaders';
import vue from '@vitejs/plugin-vue';

const LAYOUT_PLUGIN_NAME = "vite:hybridly:layout";
const CONFIG_PLUGIN_NAME = "vite:hybridly:config";
const CONFIG_VIRTUAL_MODULE_ID = "virtual:hybridly/config";
const RESOLVED_CONFIG_VIRTUAL_MODULE_ID = `\0${CONFIG_VIRTUAL_MODULE_ID}`;

const debug = {
  config: makeDebugger(CONFIG_PLUGIN_NAME),
  layout: makeDebugger(LAYOUT_PLUGIN_NAME)
};
function isPackageInstalled(name, paths = [process.cwd()]) {
  return isPackageExists(name, { paths });
}
function importPackage(name, paths = [process.cwd()]) {
  const mod = resolveModule(name, { paths });
  if (!mod) {
    console.warn(`Could not resolve package [${name}]`);
    return;
  }
  return importModule(mod);
}
function toKebabCase(key) {
  const result = key.replace(/([A-Z])/g, " $1").trim();
  return result.split(" ").join("-").toLowerCase();
}

function generateTsConfig(options, config) {
  const tsconfig = {
    compilerOptions: {
      target: "esnext",
      module: "esnext",
      moduleResolution: "node",
      strict: true,
      jsx: "preserve",
      sourceMap: true,
      resolveJsonModule: true,
      esModuleInterop: true,
      allowSyntheticDefaultImports: true,
      lib: [
        "esnext",
        "dom"
      ],
      types: [
        "vite/client",
        "hybridly/client",
        ...options.icons !== false ? ["unplugin-icons/types/vue"] : [],
        ...options.tsconfig?.types ?? []
      ],
      baseUrl: "..",
      paths: {
        "#/*": [
          ".hybridly/*"
        ],
        "~/*": [
          "./*"
        ],
        "@/*": [
          `./${config.architecture.root}/*`
        ]
      }
    },
    include: [
      ...config.components.views.map(({ path: path2 }) => `../${path2}`),
      ...config.components.layouts.map(({ path: path2 }) => `../${path2}`),
      ...config.components.components.map(({ path: path2 }) => `../${path2}`),
      `../${config.architecture.root}/**/*`,
      "../app/**/*",
      "../src/**/*",
      "./php-types.d.ts",
      "./global-types.d.ts",
      "./routes.d.ts",
      "./components.d.ts",
      "./auto-imports.d.ts",
      ...options.tsconfig?.include ?? []
    ],
    exclude: [
      "../public/**/*",
      "../node_modules",
      "../vendor",
      ...options.tsconfig?.exclude ?? []
    ]
  };
  write(JSON.stringify(tsconfig, null, 2), "tsconfig.json");
}
function generateLaravelIdeaHelper(config) {
  const ideJson = {
    $schema: "https://laravel-ide.com/schema/laravel-ide-v2.json",
    completions: [
      {
        complete: "staticStrings",
        options: {
          strings: config.components.views.map(({ identifier }) => identifier)
        },
        condition: [
          {
            functionNames: ["hybridly"],
            parameters: [1]
          }
        ]
      }
    ]
  };
  write(JSON.stringify(ideJson, null, 2), "ide.json");
}
async function generateRouteDefinitionFile(options, config) {
  const routing = config?.routing;
  if (!routing) {
    return;
  }
  debug.config("Writing types for routing:", routing);
  const routes = Object.fromEntries(Object.entries(routing.routes).map(([key, route]) => {
    const bindings = route.bindings ? Object.fromEntries(Object.entries(route.bindings).map(([key2]) => [key2, "__key_placeholder__"])) : void 0;
    return [key, {
      ...route.uri ? { uri: route.uri } : {},
      ...route.domain ? { domain: route.domain } : {},
      ...route.wheres ? { wheres: route.wheres } : {},
      ...route.bindings ? { bindings } : {}
    }];
  }));
  const definitions = `
		/* eslint-disable */
		/* prettier-ignore */
		// This file has been automatically generated by Hybridly
		// Modifications will be discarded
		
		declare module 'hybridly' {
			export interface GlobalRouteCollection {
				url: '__URL__'
				routes: __ROUTES__
			}
		}
		
		export {}
	`.replace("__URL__", routing?.url ?? "").replace("__ROUTES__", JSON.stringify(routes).replaceAll('"__key_placeholder__"', "any"));
  write(definitions, "routes.d.ts");
}
function write(data, filename) {
  const hybridlyPath = path.resolve(process.cwd(), ".hybridly");
  if (!fs.existsSync(hybridlyPath)) {
    fs.mkdirSync(hybridlyPath);
  }
  fs.writeFileSync(path.resolve(hybridlyPath, filename), data, {
    encoding: "utf-8"
  });
}

async function loadConfiguration(options) {
  try {
    const php = options.php ?? process.env.PHP_EXECUTABLE_PATH ?? "php";
    const stdout = execSync(`${php} artisan hybridly:config`);
    return JSON.parse(stdout.toString("utf-8"));
  } catch (e) {
    console.error("Could not load configuration from [php artisan].");
    throw e;
  }
}

function getClientCode(config) {
  const paths = config.components.views.map(({ path }) => `"~/${path}"`).join(",");
  return `
		import { initializeHybridly as init } from 'hybridly/vue'

		export function initializeHybridly(config) {
			return init({
				...${JSON.stringify(config)},
				imported: import.meta.glob([${paths}], { eager: ${config.components.eager ?? true} }),
				...config,
			})
		}
 `;
}

const initialize = (options, config) => {
  generateTsConfig(options, config);
  generateLaravelIdeaHelper(config);
  generateRouteDefinitionFile(options, config);
  return {
    name: CONFIG_PLUGIN_NAME,
    enforce: "pre",
    config() {
      return {
        resolve: {
          alias: {
            "@": path.join(process.cwd(), config.architecture.root),
            "#": path.join(process.cwd(), ".hybridly"),
            "~": path.join(process.cwd())
          }
        }
      };
    },
    configureServer(server) {
      let restarting = false;
      async function forceRestart(message) {
        if (restarting) {
          return;
        }
        restarting = true;
        server.config.logger.info(`${message}: forcing a server restart.`, {
          clear: server.config.clearScreen,
          timestamp: true
        });
        return await server?.restart();
      }
      async function handleFileChange(file) {
        if (file.endsWith("config/hybridly.php")) {
          return await forceRestart("Configuration file changed");
        }
        if (/routes\/.*\.php/.test(file) || /routes\.php/.test(file)) {
          return await forceRestart("Routing changed");
        }
        if (/.*\.vue$/.test(file)) {
          const updatedConfig = await loadConfiguration(options);
          const viewsOrLayoutsChanged = didViewsOrLayoutsChange(updatedConfig, config);
          if (viewsOrLayoutsChanged) {
            return await forceRestart("View or layout changed");
          }
        }
      }
      server.watcher.on("add", handleFileChange);
      server.watcher.on("change", handleFileChange);
      server.watcher.on("unlink", handleFileChange);
    },
    resolveId(id) {
      if (id === CONFIG_VIRTUAL_MODULE_ID) {
        return RESOLVED_CONFIG_VIRTUAL_MODULE_ID;
      }
    },
    async load(id) {
      if (id === RESOLVED_CONFIG_VIRTUAL_MODULE_ID) {
        return getClientCode(config);
      }
    },
    // Denies HMR for `.hybridly` content, it causes unwanted reloads
    async handleHotUpdate(ctx) {
      if (ctx.file.includes(".hybridly")) {
        return [];
      }
    }
  };
};
function didViewsOrLayoutsChange(updatedConfig, previousConfig) {
  if (!previousConfig) {
    return false;
  }
  return JSON.stringify(updatedConfig.components.views) !== JSON.stringify(previousConfig.components.views) || JSON.stringify(updatedConfig.components.layouts) !== JSON.stringify(previousConfig.components.layouts);
}

const TEMPLATE_LAYOUT_REGEX = /<template +layout(?: *= *['"]((?:[\w\/\-_,:](?:,\ )?)+)['"] *)?>/;
const TYPESCRIPT_REGEX = /lang=['"]ts['"]/;
const layout = (options, config) => {
  const defaultLayoutName = options?.layout?.defaultLayoutName?.replace(".vue", "") ?? "default";
  const templateRegExp = options?.layout?.templateRegExp ?? TEMPLATE_LAYOUT_REGEX;
  debug.layout("Resolved options:", {
    defaultLayoutName
  });
  return {
    name: LAYOUT_PLUGIN_NAME,
    enforce: "pre",
    transform: (code, id) => {
      if (!templateRegExp.test(code)) {
        return;
      }
      const source = new MagicString(code);
      const updatedCode = source.replace(templateRegExp, (_, layoutName) => {
        const isTypeScript = TYPESCRIPT_REGEX.test(code);
        const layouts = layoutName?.toString()?.replaceAll(" ", "").split(",") ?? [defaultLayoutName];
        const importName = (i) => `__hybridly_layout_${i}`;
        const exports = layouts.map((_2, i) => importName(i));
        const imports = layouts.reduce((imports2, layoutName2, i) => `
					${imports2}
					import ${importName(i)} from '${resolveLayoutImportPath(layoutName2, config)}';
				`, "").trim();
        debug.layout(`Resolved layouts "${layouts.join(", ")}":`, {
          sourceFile: id,
          layouts,
          imports
        });
        return `
					<script${isTypeScript ? ' lang="ts"' : ""}>
					${imports}
					export default { layout: [${exports.join(", ")}] }
					<\/script>
					<template>
				`;
      });
      return {
        map: updatedCode.generateMap(),
        code: updatedCode.toString()
      };
    }
  };
};
function resolveLayoutImportPath(name, config) {
  const { path } = config.components.layouts.find((layout) => layout.identifier === name) ?? {};
  if (!path) {
    throw new Error(`Layout [${name}] could not be found.`);
  }
  return `~/${path}`;
}

function getRunOptions(options) {
  if (options.run === false) {
    return [];
  }
  return [
    {
      name: "Generate TypeScript types",
      run: ["php", "artisan", "hybridly:types"],
      pattern: [
        "+(app|src)/**/*Data.php",
        "+(app|src)/**/Enums/*.php",
        "+(app|src)/**/Middleware/HandleHybridRequests.php"
      ]
    },
    {
      name: "Generate i18n",
      run: ["php", "artisan", "hybridly:i18n"],
      pattern: "lang/**/*.php"
    },
    ...options.run ?? []
  ];
}

function getLaravelOptions(options, config) {
  return {
    input: `${config.architecture.root}/application/main.ts`,
    ...options.laravel ?? {}
  };
}

const HybridlyImports = {
  "hybridly/vue": [
    "useProperty",
    "setProperty",
    "useRefinements",
    "useTable",
    "useBulkSelect",
    "useProperties",
    "useBackForward",
    "useContext",
    "useForm",
    "useDialog",
    "useHistoryState",
    "usePaginator",
    "defineLayout",
    "defineLayoutProperties",
    "registerHook",
    "useRoute",
    "useQueryParameters"
  ],
  "hybridly": [
    "router",
    "route",
    "can"
  ]
};
function getAutoImportsOptions(options, config) {
  if (options.autoImports === false) {
    return;
  }
  const presets = ["@vueuse/core", "vue-i18n"];
  const custom = {
    "@unhead/vue": [
      "useHead",
      "useSeoMeta"
    ],
    "@innocenzi/utils": [
      "match",
      "invoke",
      "batchInvoke",
      "asyncInvoke"
    ]
  };
  return merge(
    {
      vueTemplate: true,
      dts: ".hybridly/auto-imports.d.ts",
      dirs: [
        `${config.architecture.root}/utils`,
        `${config.architecture.root}/composables`,
        ...config.components.directories.map((directory) => `${directory}/**/*.ts`)
      ],
      imports: [
        "vue",
        "vue/macros",
        ...presets.filter((pkg) => isPackageInstalled(pkg)),
        ...Object.entries(custom).filter(([pkg]) => isPackageInstalled(pkg)).map(([pkg, imports]) => ({ [pkg]: imports })),
        HybridlyImports
      ]
    },
    options.autoImports ?? {},
    { overwriteArray: false }
  );
}

async function getVueComponentsOptions(options, config) {
  if (options.vueComponents === false) {
    return {};
  }
  const hasIcons = options?.icons !== false;
  const customCollections = Array.isArray(options.customIcons) ? options.customIcons : options.customIcons?.collections ?? [];
  const overrideResolvers = options.overrideResolvers ? Array.isArray(options.overrideResolvers) ? options.overrideResolvers : [options.overrideResolvers] : false;
  const hasHeadlessUI = isPackageInstalled("@headlessui/vue");
  const hasRadix = isPackageInstalled("radix-vue");
  return merge(
    {
      dirs: [
        `./${config.architecture.root}/components`
      ],
      directoryAsNamespace: true,
      dts: ".hybridly/components.d.ts",
      resolvers: overrideResolvers || [
        ...hasIcons ? [iconsResolver({ customCollections })] : [],
        ...hasHeadlessUI ? [HeadlessUiResolver({ prefix: options?.vueComponents?.headlessUiPrefix ?? "Headless" })] : [],
        ...hasRadix ? [await RadixResolver(options?.vueComponents?.radixPrefix)] : [],
        ProvidedComponentListResolver(config),
        HybridlyResolver(options.vueComponents?.linkName)
      ]
    },
    options.vueComponents ?? {},
    { overwriteArray: false }
  );
}
async function RadixResolver(prefix = "Radix") {
  const radix = await importPackage("radix-vue/resolver");
  return radix.default({ prefix });
}
function HybridlyResolver(linkName = "RouterLink") {
  return {
    type: "component",
    resolve: (name) => {
      if (name === linkName) {
        return {
          from: "hybridly/vue",
          name: "RouterLink",
          as: linkName
        };
      }
    }
  };
}
function ProvidedComponentListResolver(config) {
  function resolveComponentPath(name) {
    const kebabName = toKebabCase(name);
    const path = config.components.components.find((view) => {
      const identifierAsComponentName = view.identifier.replace("::", "-").replace(".", "-");
      return identifierAsComponentName === kebabName;
    })?.path;
    if (!path) {
      return;
    }
    return `~/${path}`;
  }
  return {
    type: "component",
    resolve: (name) => resolveComponentPath(name)
  };
}

function getIconsOptions(options, config) {
  if (options.icons === false) {
    return {};
  }
  const resolved = Array.isArray(options.customIcons) ? { icons: void 0, collections: options.customIcons } : options.customIcons;
  const customIconDirectoryName = resolved?.icons ?? "icons";
  const customCollections = Object.fromEntries(resolved?.collections?.map((collection) => [
    collection,
    FileSystemIconLoader(`./${config.architecture.root}/${customIconDirectoryName}/${collection}`)
  ]) ?? []);
  return {
    autoInstall: true,
    customCollections,
    ...options.icons
  };
}

function getVueOptions(options) {
  if (options.vue === false) {
    return;
  }
  return merge(
    {
      template: {
        transformAssetUrls: {
          base: null,
          includeAbsolute: false
        },
        ...options.vue?.template
      },
      script: {
        globalTypeFiles: [
          path.resolve(".hybridly/php-types.d.ts")
        ],
        defineModel: true,
        ...options.vue?.script
      }
    },
    options.vue ?? {},
    { overwriteArray: false }
  );
}

function killSwitch() {
  let _enabled = false;
  return {
    name: "hybridly:build:kill-switch",
    config: ({ mode }) => {
      if (mode === "build") {
        _enabled = true;
      }
    },
    buildEnd: (error) => {
      if (!_enabled) {
        return;
      }
      if (error) {
        console.error("Error when bundling");
        console.error(error);
        process.exit(1);
      }
    },
    closeBundle: () => {
      if (!_enabled) {
        return;
      }
      process.exit(0);
    }
  };
}

async function plugin(options = {}) {
  const config = await loadConfiguration(options);
  return [
    initialize(options, config),
    layout(options, config),
    options.laravel !== false && laravel(getLaravelOptions(options, config)),
    options.run !== false && run(getRunOptions(options)),
    options.vueComponents !== false && vueComponents(await getVueComponentsOptions(options, config)),
    options.autoImports !== false && autoimport(getAutoImportsOptions(options, config)),
    options.icons !== false && icons(getIconsOptions(options, config)),
    options.vue !== false && vue(getVueOptions(options)),
    options.killSwitch !== false && killSwitch()
  ];
}

export { HybridlyImports, HybridlyResolver, plugin as default, layout };
